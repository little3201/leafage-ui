<template>
  <q-dialog v-model="visible" persistent>
    <q-card style="min-width: 25em">
      <q-form @submit="onSubmit">
        <q-card-section>
          <div class="text-h6">{{ $t('page.schemas') }}</div>
        </q-card-section>

        <q-card-section>
          <div class="row q-col-gutter-x-md">
            <q-select outlined dense options-dense v-model="form.name" option-value="name" option-label="name"
              :options="tables" emit-value :label="$t('label.name')" class="col-6"
              :rules="[val => val && val.length > 0 || $t('placeholder.selectText')]" />
            <q-input outlined dense v-model="form.prefix" :label="$t('label.prefix')" class="col-6" />
          </div>

          <q-input outlined dense v-model="form.packageName" :label="$t('label.packageName')" lazy-rules
            :rules="[val => val && val.length > 0 || $t('placeholder.inputText')]" />

          <div class="row items-center q-gutter-xs" v-for="(items, group) in groupByKey(samples, 'module')"
            :key="group">
            <strong>{{ group }}: </strong>
            <div class="inline-flex flex-wrap gap-2">
              <q-chip v-for="(item, idx) in items" :key="idx" :selected="form.samples?.includes(item.id as number)">
                {{ item.name }}
              </q-chip>
            </div>
          </div>
        </q-card-section>

        <q-card-actions align="right">
          <q-btn title="cancel" type="reset" unelevated :label="$t('action.cancel')" v-close-popup />
          <q-btn title="submit" type="submit" flat :label="$t('action.submit')" color="primary" />
        </q-card-actions>
      </q-form>
    </q-card>
  </q-dialog>

  <q-table ref="tableRef" flat :title="$t('page.schemas')" :rows="rows" :columns="columns" row-key="id"
    :loading="loading" v-model:pagination="pagination" :filter="filter" binary-state-sort @request="onRequest"
    class="full-width">
    <template v-slot:top-right>
      <q-input dense debounce="300" v-model="filter.title" placeholder="Search">
        <template v-slot:append>
          <q-icon name="sym_r_search" />
        </template>
      </q-input>
      <q-btn title="create" round padding="xs" class="q-mx-sm" color="primary" :disable="loading" icon="sym_r_add"
        @click="saveRow()" />
      <q-btn title="refresh" round padding="xs" flat color="primary" :disable="loading" icon="sym_r_refresh"
        @click="refresh" />
      <q-btn title="import" round padding="xs" flat color="primary" class="q-mx-sm" :disable="loading"
        icon="sym_r_database_upload" @click="importRow" />
      <q-btn title="export" round padding="xs" flat color="primary" icon="sym_r_file_export"
        @click="exportTable(columns, rows)" />
    </template>

    <template v-slot:header="props">
      <q-tr :props="props">
        <q-th v-for="col in props.cols" :key="col.name" :props="props">
          {{ $t(`label.${col.label}`) }}
        </q-th>
      </q-tr>
    </template>

    <template v-slot:body-cell-name="props">
      <q-td :props="props">
        <q-btn v-if="props.row.samples && props.row.samples.length > 0" :title="props.row.name" flat rounded no-caps
          color="primary" @click="previewRow(props.row.id)">
          {{ props.row.name }}
        </q-btn>
        <span v-else class="q-ml-md">{{ props.row.name }}</span>
      </q-td>
    </template>
    <template v-slot:body-cell-samples="props">
      <q-td :props="props">
        <q-chip v-for="(item, index) in visibleArray(props.row.samples, 3)" :key="index" color="primary"
          text-color="white" class="q-mr-sm" size="sm">
          {{ formatSamples(item as number) }}
        </q-chip>
        <template v-if="props.row.samples && props.row.samples.length > 3">
          <q-chip color="primary" text-color="white" class="q-mr-sm" size="sm">
            + {{ props.row.samples.length - 3 }}
            <q-tooltip>
              <q-chip v-for="(item, index) in props.row.samples.slice(3)" :key="index" text-color="white"
                class="q-mr-sm" size="sm">
                {{ formatSamples(item) }}
              </q-chip>
            </q-tooltip>
          </q-chip>
        </template>
      </q-td>
    </template>
    <template v-slot:body-cell-lastModifiedDate="props">
      <q-td :props="props">
        {{ props.row.lastModifiedDate ? date.formatDate(props.row.lastModifiedDate, 'YYYY-MM-DD HH:mm') : '-' }}
      </q-td>
    </template>
    <template v-slot:body-cell-id="props">
      <q-td :props="props">
        <q-btn title="modify" padding="xs" flat round color="primary" icon="sym_r_edit"
          @click="saveRow(props.row.id)" />
        <q-btn title="config" padding="xs" flat round color="primary" icon="sym_r_rule_settings"
          @click="configRow(props.row.id)" class="q-mx-sm" />
        <q-btn title="config" padding="xs" flat round color="primary" icon="sym_r_sync" @click="syncRow(props.row.id)"
          class="q-mx-sm" />
        <q-btn title="delete" padding="xs" flat round color="negative" icon="sym_r_delete"
          @click="removeRow(props.row.id)" />
      </q-td>
    </template>
  </q-table>

  <!-- preview -->
  <q-dialog v-model="previewVisible">
    <q-card class="full-width" style="max-width: 70vw;">
      <q-card-section class="flex items-center q-pb-none">
        <div class="text-h6">{{ $t('preview') }}</div>
        <q-space />
        <q-btn icon="sym_r_close" flat round dense v-close-popup />
      </q-card-section>
      <q-card-section class="flex no-wrap" style="flex: 1;">
        <q-tree ref="treeRef" :nodes="renderedSamples" node-key="id" selected-color="primary"
          v-model:selected="currentRowId" default-expand-all style="height: 600px; min-width: 256px;"
          class="q-pr-md scroll">
          <template v-slot:default-header="prop">
            <span>{{ prop.node.name }}{{ prop.node.suffix }}</span>
          </template>
        </q-tree>

        <CodeRender :content="currentNode.content" :language="currentNode.suffix?.substring(1)" style="flex: 1;"
          class="scroll" />
      </q-card-section>
    </q-card>
  </q-dialog>

  <!-- config -->
  <q-dialog v-model="configVisible">
    <q-card style="max-width: 100em;">
      <q-card-section class="flex items-center q-pb-none">
        <div class="text-h6">{{ $t('action.config') }}</div>
        <q-space />
        <q-btn icon="sym_r_close" flat round dense v-close-popup />
      </q-card-section>

      <q-card-section class="scroll">
        <q-table flat :rows="fields" :columns="configColumns" row-key="id" binary-state-sort hide-pagination
          :pagination="{ rowsPerPage: 0 }" class="full-width">

          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th v-for="col in props.cols" :key="col.name" :props="props">
                {{ $t(`label.${col.label}`) }}
              </q-th>
            </q-tr>
          </template>
          <template v-slot:body-cell-nullable="props">
            <q-td :props="props">
              <q-badge :color="props.row.nullable ? 'positive' : 'primary'" rounded class="q-mr-sm" />
              {{ props.row.nullable ? 'Y' : 'N' }}
            </q-td>
          </template>
          <template v-slot:body-cell-unique="props">
            <q-td :props="props">
              <q-badge :color="props.row.unique ? 'positive' : 'warning'" rounded class="q-mr-sm" />
              {{ props.row.unique ? 'Y' : 'N' }}
            </q-td>
          </template>
          <template v-slot:body-cell-fieldType="props">
            <q-td :props="props">
              <q-select outlined dense options-dense v-model="props.row.fieldType" :label="$t('label.fieldType')"
                :options="fieldTypeOptions" emit-value option-value="name" option-label="name" style="width: 120px;" />
            </q-td>
          </template>
          <template v-slot:body-cell-formType="props">
            <q-td :props="props">
              <q-select outlined dense options-dense v-model="props.row.formType" :label="$t('label.formType')"
                :options="formTypeOptions" emit-value option-value="name" option-label="name" style="width: 120px;" />
            </q-td>
          </template>
          <template v-slot:body-cell-tsType="props">
            <q-td :props="props">
              <q-select outlined dense options-dense v-model="props.row.tsType" :label="$t('label.tsType')"
                :options="tsTypeOptions" emit-value option-value="name" option-label="name" style="width: 120px;" />
            </q-td>
          </template>
          <template v-slot:body-cell-queryable="props">
            <q-td :props="props">
              <q-checkbox dense v-model="props.row.queryable" />
            </q-td>
          </template>
          <template v-slot:body-cell-queryType="props">
            <q-td :props="props">
              <q-select outlined dense options-dense v-model="props.row.queryType" :label="$t('label.queryType')"
                :options="queryTypes" :disable="!props.row.queryable" style="width: 120px;" />
            </q-td>
          </template>
          <template v-slot:body-cell-editable="props">
            <q-td :props="props">
              <q-checkbox dense v-model="props.row.editable" />
            </q-td>
          </template>
          <template v-slot:body-cell-sortable="props">
            <q-td :props="props">
              <q-checkbox dense v-model="props.row.sortable" />
            </q-td>
          </template>
        </q-table>
      </q-card-section>

      <q-card-actions align="right">
        <q-btn title="cancel" type="reset" unelevated :label="$t('action.cancel')" v-close-popup />
        <q-btn title="submit" type="submit" flat :label="$t('action.submit')" color="primary" />
      </q-card-actions>
    </q-card>
  </q-dialog>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import type { QTableProps, QTree } from 'quasar'
import { date } from 'quasar'
import CodeRender from 'components/CodeRender.vue'
import {
  retrieveSchemas, retrieveSchemaFields, retrieveSchemaPreview, fetchSchema,
  createSchema, modifySchema, syncSchema, removeSchema
} from 'src/api/schemas'
import { retrieveSamples } from 'src/api/samples'
import { retrieveTables } from 'src/api/connections'
import { retrieveDictionarySubset } from 'src/api/dictionaries'
import { visibleArray, groupByKey, exportTable } from 'src/utils'
import { queryTypes } from 'src/constants'
import type { Schema, Field, Sample, SampleTreeNode, Dictionary } from 'src/types'


const props = defineProps<{
  connectionId: number,
  title: string
}>()
const visible = ref<boolean>(false)
const importVisible = ref<boolean>(false)
const previewVisible = ref<boolean>(false)
const configVisible = ref<boolean>(false)

const tableRef = ref()
const rows = ref<QTableProps['rows']>([])
const filter = ref({
  connectionId: 'eq:' + props.connectionId,
  title: ''
})
const loading = ref<boolean>(false)
const syncLoading = ref<boolean>(false)

const tables = ref<Array<string>>([])
const fields = ref<Array<Field>>([])
const samples = ref<Array<Sample>>([])
const sampleTypeOptions = ref<Array<Dictionary>>([])
const fieldTypeOptions = ref<Array<Dictionary>>([])
const formTypeOptions = ref<Array<Dictionary>>([])
const tsTypeOptions = ref<Array<Dictionary>>([])
const renderedSamples = ref<Array<SampleTreeNode>>([])
const currentRowId = ref<number | null>(null)
const currentNode = ref<SampleTreeNode>({
  name: ''
})
const treeRef = ref<QTree | null>(null)

const initialValues: Schema = {
  id: undefined,
  name: '',
  connectionId: props.connectionId,
  packageName: '',
  samples: []
}
const form = ref<Schema>({ ...initialValues })

const pagination = ref({
  sortBy: 'id',
  descending: true,
  page: 1,
  rowsPerPage: 7,
  rowsNumber: 0
})

const columns: QTableProps['columns'] = [
  { name: 'name', label: 'name', align: 'left', field: 'name', sortable: true },
  { name: 'prefix', label: 'prefix', align: 'left', field: 'prefix' },
  { name: 'packageName', label: 'packageName', align: 'left', field: 'packageName' },
  { name: 'samples', label: 'samples', align: 'left', field: 'samples' },
  { name: 'id', label: 'actions', field: 'id' }
]

const configColumns: QTableProps['columns'] = [
  { name: 'name', label: 'name', align: 'left', field: 'name', sortable: true },
  { name: 'dataType', label: 'type', align: 'left', field: 'dataType' },
  { name: 'length', label: 'length', align: 'left', field: 'length' },
  { name: 'nullable', label: 'nullable', align: 'left', field: 'nullable' },
  { name: 'unique', label: 'unique', align: 'left', field: 'unique' },
  { name: 'comment', label: 'comment', align: 'left', field: 'comment' },
  { name: 'fieldType', label: 'fieldType', align: 'left', field: 'fieldType' },
  { name: 'formType', label: 'formType', align: 'left', field: 'formType' },
  { name: 'tsType', label: 'tsType', align: 'left', field: 'tsType' },
  { name: 'queryable', label: 'queryable', align: 'left', field: 'queryable' },
  { name: 'queryType', label: 'queryType', align: 'left', field: 'queryType' },
  { name: 'editable', label: 'editable', align: 'left', field: 'editable' },
  { name: 'sortable', label: 'sortable', align: 'left', field: 'sortable' }
]

onMounted(async () => {
  refresh()

  const sampleRes = await retrieveSamples({ page: 1, size: 99 })
  samples.value = sampleRes.data.content

  const typeRes = await retrieveDictionarySubset(700)
  sampleTypeOptions.value = typeRes.data

})

watch(
  () => currentRowId.value,
  (nodeKey) => {
    if (treeRef.value && nodeKey) {
      const node = treeRef.value.getNodeByKey(nodeKey)
      if (!node || currentNode.value.id === node.id || !node.suffix) {
        return
      }
      currentNode.value = node
    }
  }
)

/**
 * 查询列表
 */
async function onRequest(props: Parameters<NonNullable<QTableProps['onRequest']>>[0]) {
  loading.value = true

  const { page, rowsPerPage, sortBy, descending } = props.pagination
  const filter = props.filter

  const params = { page, size: rowsPerPage, sortBy, descending }

  try {
    const res = await retrieveSchemas({ ...params }, filter)
    pagination.value.page = page
    pagination.value.rowsPerPage = rowsPerPage
    pagination.value.sortBy = sortBy
    pagination.value.descending = descending

    rows.value = res.data.content
    pagination.value.rowsNumber = res.data.totalElements
  } catch {
    return Promise.resolve()
  } finally {
    loading.value = false
  }
}

function refresh() {
  tableRef.value.requestServerInteraction()
}

async function loadSchemaFields(id: number) {
  try {
    const res = await retrieveSchemaFields(id)
    fields.value = res.data
  } catch {
    return Promise.resolve()
  }
}

async function saveRow(id?: number) {
  form.value = { ...initialValues }
  try {
    if (id) {
      const res = await fetchSchema(id)
      form.value = res.data
    }
    const tableRes = await retrieveTables(props.connectionId)
    tables.value = tableRes.data
  } catch {
    return Promise.resolve()
  }
  visible.value = true
}

function importRow() {
  importVisible.value = true
}

async function previewRow(id: number) {
  try {
    const res = await retrieveSchemaPreview(id)
    renderedSamples.value = res.data
  } catch {
    return Promise.resolve()
  }
  previewVisible.value = true
}

async function configRow(id: number) {
  try {
    await loadSchemaFields(id)

    const [fieldTypeRes, formTypeRes, tsTypeRes, schemaFieldsRes] = await Promise.all([
      retrieveDictionarySubset(200),
      retrieveDictionarySubset(300),
      retrieveDictionarySubset(400),
      retrieveSchemaFields(id)])
    fieldTypeOptions.value = fieldTypeRes.data
    formTypeOptions.value = formTypeRes.data
    tsTypeOptions.value = tsTypeRes.data
    fields.value = schemaFieldsRes.data
  } catch {
    return Promise.resolve()
  }
  configVisible.value = true
}

async function syncRow(id: number) {
  syncLoading.value = true
  try {
    await syncSchema(id)
    refresh()
  } catch {
    return Promise.resolve()
  } finally {
    syncLoading.value = false
  }
}

async function removeRow(id: number) {
  loading.value = true
  try {
    await removeSchema(id)
    refresh()
  } catch {
    return Promise.resolve()
  } finally {
    loading.value = false
  }
}

async function onSubmit() {
  try {
    if (form.value.id) {
      await modifySchema(form.value.id, form.value)
    } else {
      await createSchema(form.value)
    }
    refresh()
  } catch {
    return Promise.resolve()
  }
  // Close the dialog after submitting
  visible.value = false
}

/**
   * format samples
   * @param cellValue cell value
   */
function formatSamples(cellValue: number): string {
  const templateItem = samples.value.find(item => item.id === cellValue)
  return templateItem ? templateItem.name : ''
}
</script>
